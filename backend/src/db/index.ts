import { drizzle } from "drizzle-orm/bun-sqlite"
import { Database } from "bun:sqlite"
import * as schema from "./schema"
import { logger } from "../utils/logger"
import { generateAdminPassword } from "../utils/password"

const sqlite = new Database(process.env.DATABASE_URL || "./netdisk.db")
export const db = drizzle(sqlite, { schema })

// Initialize database with auto-migration
async function initializeDatabase() {
  try {
    logger.startup('üîß ÂºÄÂßãÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì...')

    // ÂàõÂª∫Âü∫Á°ÄË°®
    sqlite.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        role TEXT NOT NULL DEFAULT 'user',
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS folders (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        name TEXT NOT NULL,
        parent_id TEXT,
        path TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (parent_id) REFERENCES folders (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS files (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        folder_id TEXT,
        filename TEXT NOT NULL,
        original_name TEXT NOT NULL,
        size INTEGER NOT NULL,
        mime_type TEXT NOT NULL,
        storage_type TEXT NOT NULL,
        storage_path TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (folder_id) REFERENCES folders (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS storage_config (
        id INTEGER PRIMARY KEY DEFAULT 1,
        storage_type TEXT NOT NULL DEFAULT 'local',
        r2_endpoint TEXT,
        r2_access_key TEXT,
        r2_secret_key TEXT,
        r2_bucket TEXT,
        onedrive_client_id TEXT,
        onedrive_client_secret TEXT,
        onedrive_tenant_id TEXT,
        onedrive_webdav_url TEXT,
        onedrive_webdav_user TEXT,
        onedrive_webdav_pass TEXT,
        enable_mixed_mode INTEGER NOT NULL DEFAULT 0,
        updated_at INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS r2_mount_points (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        folder_id TEXT NOT NULL,
        r2_path TEXT NOT NULL,
        mount_name TEXT NOT NULL,
        enabled INTEGER NOT NULL DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (folder_id) REFERENCES folders (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS onedrive_auth (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        access_token TEXT NOT NULL,
        refresh_token TEXT NOT NULL,
        expires_at INTEGER NOT NULL,
        scope TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS onedrive_mount_points (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        folder_id TEXT NOT NULL,
        onedrive_path TEXT NOT NULL,
        onedrive_item_id TEXT,
        mount_name TEXT NOT NULL,
        enabled INTEGER NOT NULL DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (folder_id) REFERENCES folders (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS email_verification_codes (
        id TEXT PRIMARY KEY,
        email TEXT NOT NULL,
        code TEXT NOT NULL,
        expires_at INTEGER NOT NULL,
        used INTEGER NOT NULL DEFAULT 0,
        created_at INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS smtp_config (
        id INTEGER PRIMARY KEY DEFAULT 1,
        enabled INTEGER DEFAULT 0,
        host TEXT,
        port INTEGER DEFAULT 465,
        user TEXT,
        pass TEXT,
        secure INTEGER DEFAULT 1,
        email_template TEXT,
        updated_at INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS download_tokens (
        id TEXT PRIMARY KEY,
        file_id TEXT NOT NULL,
        user_id TEXT NOT NULL,
        token TEXT UNIQUE NOT NULL,
        used INTEGER NOT NULL DEFAULT 0,
        usage_count INTEGER NOT NULL DEFAULT 0,
        max_usage INTEGER NOT NULL DEFAULT 2,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS file_direct_links (
        id TEXT PRIMARY KEY,
        file_id TEXT UNIQUE NOT NULL,
        user_id TEXT NOT NULL,
        direct_name TEXT UNIQUE NOT NULL,
        token TEXT UNIQUE NOT NULL,
        enabled INTEGER NOT NULL DEFAULT 1,
        access_count INTEGER NOT NULL DEFAULT 0,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS direct_link_access_logs (
        id TEXT PRIMARY KEY,
        direct_link_id TEXT NOT NULL,
        ip_address TEXT NOT NULL,
        user_agent TEXT,
        country TEXT,
        province TEXT,
        city TEXT,
        isp TEXT,
        accessed_at INTEGER NOT NULL,
        FOREIGN KEY (direct_link_id) REFERENCES file_direct_links (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS ip_bans (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        direct_link_id TEXT,
        ip_address TEXT NOT NULL,
        reason TEXT,
        enabled INTEGER NOT NULL DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (direct_link_id) REFERENCES file_direct_links (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS file_shares (
        id TEXT PRIMARY KEY,
        file_id TEXT NOT NULL,
        user_id TEXT NOT NULL,
        share_token TEXT UNIQUE,
        pickup_code TEXT,
        require_login INTEGER NOT NULL DEFAULT 0,
        gatekeeper INTEGER NOT NULL DEFAULT 0,
        custom_file_name TEXT,
        custom_file_extension TEXT,
        custom_file_size INTEGER,
        enabled INTEGER NOT NULL DEFAULT 1,
        access_count INTEGER NOT NULL DEFAULT 0,
        expires_at INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS user_quotas (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        max_storage INTEGER NOT NULL,
        used_storage INTEGER NOT NULL DEFAULT 0,
        role TEXT NOT NULL DEFAULT 'user',
        custom_quota INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS role_quota_config (
        id TEXT PRIMARY KEY,
        role TEXT UNIQUE NOT NULL,
        default_quota INTEGER NOT NULL,
        description TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );
    `)

    // Ê£ÄÊü•Âπ∂Ê∑ªÂä† email_verified Â≠óÊÆµ
    const userColumns = sqlite.prepare("PRAGMA table_info(users)").all() as Array<{ name: string }>
    const hasEmailVerified = userColumns.some(col => col.name === 'email_verified')

    if (!hasEmailVerified) {
      logger.dbInfo('Ê∑ªÂä† email_verified Â≠óÊÆµÂà∞ users Ë°®...')
      sqlite.exec('ALTER TABLE users ADD COLUMN email_verified INTEGER DEFAULT 0')
      logger.database('ALTER', 'users')
      logger.dbInfo('email_verified Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    // Ê£ÄÊü•Âπ∂Ê∑ªÂä† folder_id Â≠óÊÆµÂà∞ files Ë°®
    const fileColumns = sqlite.prepare("PRAGMA table_info(files)").all() as Array<{ name: string }>
    const hasFolderId = fileColumns.some(col => col.name === 'folder_id')

    if (!hasFolderId) {
      logger.dbInfo('Ê∑ªÂä† folder_id Â≠óÊÆµÂà∞ files Ë°®...')
      sqlite.exec('ALTER TABLE files ADD COLUMN folder_id TEXT')
      logger.database('ALTER', 'files')
      logger.dbInfo('folder_id Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    // Ê£ÄÊü•Âπ∂Ê∑ªÂä† enable_mixed_mode Â≠óÊÆµÂà∞ storage_config Ë°®
    const storageConfigColumns = sqlite.prepare("PRAGMA table_info(storage_config)").all() as Array<{ name: string }>
    const hasEnableMixedMode = storageConfigColumns.some(col => col.name === 'enable_mixed_mode')

    if (!hasEnableMixedMode) {
      logger.dbInfo('Ê∑ªÂä† enable_mixed_mode Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN enable_mixed_mode INTEGER NOT NULL DEFAULT 0')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('enable_mixed_mode Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    // Ê£ÄÊü•Âπ∂Ê∑ªÂä† OneDrive Áõ∏ÂÖ≥Â≠óÊÆµÂà∞ storage_config Ë°®
    const hasOneDriveClientId = storageConfigColumns.some(col => col.name === 'onedrive_client_id')
    const hasOneDriveClientSecret = storageConfigColumns.some(col => col.name === 'onedrive_client_secret')
    const hasOneDriveTenantId = storageConfigColumns.some(col => col.name === 'onedrive_tenant_id')
    const hasOneDriveWebDavUrl = storageConfigColumns.some(col => col.name === 'onedrive_webdav_url')
    const hasOneDriveWebDavUser = storageConfigColumns.some(col => col.name === 'onedrive_webdav_user')
    const hasOneDriveWebDavPass = storageConfigColumns.some(col => col.name === 'onedrive_webdav_pass')

    if (!hasOneDriveClientId) {
      logger.dbInfo('Ê∑ªÂä† onedrive_client_id Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN onedrive_client_id TEXT')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('onedrive_client_id Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    if (!hasOneDriveClientSecret) {
      logger.dbInfo('Ê∑ªÂä† onedrive_client_secret Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN onedrive_client_secret TEXT')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('onedrive_client_secret Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    if (!hasOneDriveTenantId) {
      logger.dbInfo('Ê∑ªÂä† onedrive_tenant_id Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN onedrive_tenant_id TEXT')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('onedrive_tenant_id Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    if (!hasOneDriveWebDavUrl) {
      logger.dbInfo('Ê∑ªÂä† onedrive_webdav_url Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN onedrive_webdav_url TEXT')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('onedrive_webdav_url Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    if (!hasOneDriveWebDavUser) {
      logger.dbInfo('Ê∑ªÂä† onedrive_webdav_user Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN onedrive_webdav_user TEXT')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('onedrive_webdav_user Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    if (!hasOneDriveWebDavPass) {
      logger.dbInfo('Ê∑ªÂä† onedrive_webdav_pass Â≠óÊÆµÂà∞ storage_config Ë°®...')
      sqlite.exec('ALTER TABLE storage_config ADD COLUMN onedrive_webdav_pass TEXT')
      logger.database('ALTER', 'storage_config')
      logger.dbInfo('onedrive_webdav_pass Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
    }

    // Ê£ÄÊü•Âπ∂‰øÆÂ§ç email_verification_codes Ë°®ÁöÑ used Â≠óÊÆµÁ∫¶Êùü
    const emailVerificationExists = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name='email_verification_codes'
    `).get()

    if (emailVerificationExists) {
      const emailVerificationColumns = sqlite.prepare("PRAGMA table_info(email_verification_codes)").all() as Array<{ name: string; notnull: number }>
      const usedColumn = emailVerificationColumns.find(col => col.name === 'used')

      if (usedColumn && usedColumn.notnull === 0) {
        logger.dbInfo('‰øÆÂ§ç email_verification_codes Ë°®ÁöÑ used Â≠óÊÆµÁ∫¶Êùü...')
        // Áî±‰∫é SQLite ‰∏çÊîØÊåÅÁõ¥Êé•‰øÆÊîπÂàóÁ∫¶ÊùüÔºåÊàë‰ª¨ÈúÄË¶ÅÈáçÂª∫Ë°®
        sqlite.exec(`
          CREATE TABLE email_verification_codes_new (
            id TEXT PRIMARY KEY,
            email TEXT NOT NULL,
            code TEXT NOT NULL,
            expires_at INTEGER NOT NULL,
            used INTEGER NOT NULL DEFAULT 0,
            created_at INTEGER NOT NULL
          );

          INSERT INTO email_verification_codes_new (id, email, code, expires_at, used, created_at)
          SELECT id, email, code, expires_at, IFNULL(used, 0), created_at FROM email_verification_codes;

          DROP TABLE email_verification_codes;
          ALTER TABLE email_verification_codes_new RENAME TO email_verification_codes;
        `)
        logger.database('REBUILD', 'email_verification_codes')
        logger.dbInfo('email_verification_codes Ë°®ÁªìÊûÑ‰øÆÂ§çÂÆåÊàê')
      }
    }

    // Ê£ÄÊü•Âπ∂ÂçáÁ∫ß download_tokens Ë°®ÁªìÊûÑ
    const downloadTokensExists = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name='download_tokens'
    `).get()

    if (downloadTokensExists) {
      const downloadTokenColumns = sqlite.prepare("PRAGMA table_info(download_tokens)").all() as Array<{ name: string }>
      const hasUsageCount = downloadTokenColumns.some(col => col.name === 'usage_count')
      const hasMaxUsage = downloadTokenColumns.some(col => col.name === 'max_usage')

      if (!hasUsageCount) {
        logger.dbInfo('Ê∑ªÂä† usage_count Â≠óÊÆµÂà∞ download_tokens Ë°®...')
        sqlite.exec('ALTER TABLE download_tokens ADD COLUMN usage_count INTEGER NOT NULL DEFAULT 0')
        logger.database('ALTER', 'download_tokens')
        logger.dbInfo('usage_count Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      if (!hasMaxUsage) {
        logger.dbInfo('Ê∑ªÂä† max_usage Â≠óÊÆµÂà∞ download_tokens Ë°®...')
        sqlite.exec('ALTER TABLE download_tokens ADD COLUMN max_usage INTEGER NOT NULL DEFAULT 2')
        logger.database('ALTER', 'download_tokens')
        logger.dbInfo('max_usage Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      // ËøÅÁßªÁé∞ÊúâÊï∞ÊçÆÔºöÂ∞Ü used=1 ÁöÑËÆ∞ÂΩïËÆæÁΩÆ‰∏∫Â∑≤ËææÂà∞ÊúÄÂ§ß‰ΩøÁî®Ê¨°Êï∞
      if (!hasUsageCount || !hasMaxUsage) {
        logger.dbInfo('ËøÅÁßªÁé∞Êúâ‰∏ãËΩΩ‰ª§ÁâåÊï∞ÊçÆ...')
        const updateResult = sqlite.exec(`
          UPDATE download_tokens
          SET usage_count = CASE
            WHEN used = 1 THEN max_usage
            ELSE 0
          END
          WHERE usage_count = 0 OR usage_count IS NULL
        `)
        logger.dbInfo('‰∏ãËΩΩ‰ª§ÁâåÊï∞ÊçÆËøÅÁßªÂÆåÊàê')
      }
    }

    // Ê£ÄÊü•Âπ∂ÂçáÁ∫ß file_shares Ë°®ÁªìÊûÑ
    const fileSharesExists = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name='file_shares'
    `).get()

    if (fileSharesExists) {
      const fileSharesColumns = sqlite.prepare("PRAGMA table_info(file_shares)").all() as Array<{ name: string }>
      const hasGatekeeper = fileSharesColumns.some((col: any) => col.name === 'gatekeeper')
      const hasEnabled = fileSharesColumns.some((col: any) => col.name === 'enabled')
      const hasAccessCount = fileSharesColumns.some((col: any) => col.name === 'access_count')
      const hasUpdatedAt = fileSharesColumns.some((col: any) => col.name === 'updated_at')
      const hasCustomFileName = fileSharesColumns.some((col: any) => col.name === 'custom_file_name')
      const hasCustomFileExtension = fileSharesColumns.some((col: any) => col.name === 'custom_file_extension')
      const hasCustomFileSize = fileSharesColumns.some((col: any) => col.name === 'custom_file_size')

      if (!hasGatekeeper) {
        logger.dbInfo('Ê∑ªÂä† gatekeeper Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN gatekeeper INTEGER NOT NULL DEFAULT 0')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('gatekeeper Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      if (!hasEnabled) {
        logger.dbInfo('Ê∑ªÂä† enabled Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN enabled INTEGER NOT NULL DEFAULT 1')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('enabled Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      if (!hasAccessCount) {
        logger.dbInfo('Ê∑ªÂä† access_count Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN access_count INTEGER NOT NULL DEFAULT 0')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('access_count Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      if (!hasUpdatedAt) {
        logger.dbInfo('Ê∑ªÂä† updated_at Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN updated_at INTEGER NOT NULL DEFAULT 0')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('updated_at Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')

        // Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩïÁöÑ updated_at Â≠óÊÆµ
        sqlite.exec(`UPDATE file_shares SET updated_at = created_at WHERE updated_at = 0`)
        logger.dbInfo('Â∑≤Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩïÁöÑ updated_at Â≠óÊÆµ')
      }

      if (!hasCustomFileName) {
        logger.dbInfo('Ê∑ªÂä† custom_file_name Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN custom_file_name TEXT')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('custom_file_name Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      if (!hasCustomFileExtension) {
        logger.dbInfo('Ê∑ªÂä† custom_file_extension Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN custom_file_extension TEXT')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('custom_file_extension Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      if (!hasCustomFileSize) {
        logger.dbInfo('Ê∑ªÂä† custom_file_size Â≠óÊÆµÂà∞ file_shares Ë°®...')
        sqlite.exec('ALTER TABLE file_shares ADD COLUMN custom_file_size INTEGER')
        logger.database('ALTER', 'file_shares')
        logger.dbInfo('custom_file_size Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü')
      }

      // ‰øÆÂ§ç share_token Â≠óÊÆµÁöÑ UNIQUE Á∫¶ÊùüÈóÆÈ¢ò
      const shareTokenColumn = fileSharesColumns.find((col: any) => col.name === 'share_token')
      if (shareTokenColumn && (shareTokenColumn as any).notnull === 1) {
        logger.dbInfo('‰øÆÂ§ç share_token Â≠óÊÆµÁ∫¶Êùü...')
        // Áî±‰∫é SQLite ‰∏çÊîØÊåÅÁõ¥Êé•‰øÆÊîπÂàóÁ∫¶ÊùüÔºåÊàë‰ª¨ÈúÄË¶ÅÈáçÂª∫Ë°®
        sqlite.exec(`
          CREATE TABLE file_shares_new (
            id TEXT PRIMARY KEY,
            file_id TEXT NOT NULL,
            user_id TEXT NOT NULL,
            share_token TEXT UNIQUE,
            pickup_code TEXT,
            require_login INTEGER NOT NULL DEFAULT 0,
            gatekeeper INTEGER NOT NULL DEFAULT 0,
            enabled INTEGER NOT NULL DEFAULT 1,
            access_count INTEGER NOT NULL DEFAULT 0,
            expires_at INTEGER,
            created_at INTEGER NOT NULL,
            updated_at INTEGER NOT NULL,
            FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
          );
          
          INSERT INTO file_shares_new 
          SELECT id, file_id, user_id, share_token, pickup_code, require_login, 
                 COALESCE(gatekeeper, 0), COALESCE(enabled, 1), COALESCE(access_count, 0), 
                 expires_at, created_at, COALESCE(updated_at, created_at)
          FROM file_shares;
          
          DROP TABLE file_shares;
          ALTER TABLE file_shares_new RENAME TO file_shares;
        `)
        logger.database('REBUILD', 'file_shares')
        logger.dbInfo('file_shares Ë°®ÁªìÊûÑ‰øÆÂ§çÂÆåÊàê')
      }
    }

    // Ê£ÄÊü•Âπ∂‰øÆÂ§ç file_direct_links Ë°®ÁªìÊûÑ
    await fixFileDirectLinksTable()

    // ÊèíÂÖ•ÈªòËÆ§Êï∞ÊçÆ
    sqlite.exec(`
      INSERT OR IGNORE INTO storage_config (storage_type, updated_at)
      VALUES ('local', ${Date.now()});
    `)

    // ÂàùÂßãÂåñÁÆ°ÁêÜÂëòË¥¶Êà∑
    await initializeAdminAccount()

    // ÂàùÂßãÂåñ SMTP ÈÖçÁΩÆ
    const smtpConfigExists = sqlite.prepare("SELECT COUNT(*) as count FROM smtp_config WHERE id = 1").get()
    if (smtpConfigExists.count === 0) {
      // Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáè‰∏≠ÊòØÂê¶Êúâ SMTP ÈÖçÁΩÆÔºàÂèØÈÄâÔºâ
      const hasEnvConfig = process.env.SMTP_HOST && process.env.SMTP_PORT &&
                          process.env.SMTP_USER && process.env.SMTP_PASS

      if (hasEnvConfig) {
        // ‰ªéÁéØÂ¢ÉÂèòÈáèÂàùÂßãÂåñÈÖçÁΩÆÔºàÂÖºÂÆπÊóßÁâàÊú¨Ôºâ
        sqlite.exec(`
          INSERT INTO smtp_config (id, enabled, host, port, user, pass, secure, updated_at)
          VALUES (1, 1, '${process.env.SMTP_HOST}', ${parseInt(process.env.SMTP_PORT || "465")},
                  '${process.env.SMTP_USER}', '${process.env.SMTP_PASS}', 1, ${Date.now()})
        `)
        logger.database('INSERT', 'smtp_config')
        logger.dbInfo('Â∑≤‰ªéÁéØÂ¢ÉÂèòÈáèÂàùÂßãÂåñ SMTP ÈÖçÁΩÆÔºàÂª∫ËÆÆÂú®ÁÆ°ÁêÜÈù¢Êùø‰∏≠ÁÆ°ÁêÜÔºâ')
      } else {
        // ÂàõÂª∫ÈªòËÆ§ÁöÑÁ¶ÅÁî®ÈÖçÁΩÆ
        sqlite.exec(`
          INSERT INTO smtp_config (id, enabled, host, port, user, pass, secure, updated_at)
          VALUES (1, 0, '', 465, '', '', 1, ${Date.now()})
        `)
        logger.database('INSERT', 'smtp_config')
        logger.dbInfo('Â∑≤ÂàõÂª∫ÈªòËÆ§ SMTP ÈÖçÁΩÆÔºàÁ¶ÅÁî®Áä∂ÊÄÅÔºâÔºåËØ∑Âú®ÁÆ°ÁêÜÈù¢Êùø‰∏≠ÈÖçÁΩÆ')
      }
    }

    // ÂàùÂßãÂåñÁî®Êà∑ÈÖçÈ¢ùÁ≥ªÁªü
    await initializeQuotaSystem()

    // Ê£ÄÊü•Âπ∂‰øÆÂ§ç direct_link_access_logs Ë°®ÁªìÊûÑ
    await fixDirectLinkAccessLogsTable()

    // Ê£ÄÊü•Âπ∂‰øÆÂ§ç ip_bans Ë°®ÁªìÊûÑ
    await fixIPBansTable()

    // È™åËØÅÊâÄÊúâË°®ÊòØÂê¶Ê≠£Á°ÆÂàõÂª∫
    await validateDatabaseTables()

    logger.startup('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂÆåÊàê')
  } catch (error) {
    logger.error('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•:', error)
    throw error
  }
}

// ÂàùÂßãÂåñÁî®Êà∑ÈÖçÈ¢ùÁ≥ªÁªü
async function initializeQuotaSystem() {
  try {
    logger.info('üîß ÂàùÂßãÂåñÁî®Êà∑ÈÖçÈ¢ùÁ≥ªÁªü...')

    // ÂàùÂßãÂåñËßíËâ≤ÈªòËÆ§ÈÖçÈ¢ùÈÖçÁΩÆ
    const adminQuotaExists = sqlite.prepare("SELECT COUNT(*) as count FROM role_quota_config WHERE role = 'admin'").get()
    const userQuotaExists = sqlite.prepare("SELECT COUNT(*) as count FROM role_quota_config WHERE role = 'user'").get()

    if (adminQuotaExists.count === 0) {
      const adminQuotaId = `quota_admin_${Date.now()}`
      sqlite.exec(`
        INSERT INTO role_quota_config (id, role, default_quota, description, created_at, updated_at)
        VALUES ('${adminQuotaId}', 'admin', ${10 * 1024 * 1024 * 1024}, 'ÁÆ°ÁêÜÂëòÈªòËÆ§ÈÖçÈ¢ùÔºö10GB', ${Date.now()}, ${Date.now()})
      `)
      logger.database('INSERT', 'role_quota_config')
      logger.dbInfo('Â∑≤ÂàõÂª∫ÁÆ°ÁêÜÂëòÈªòËÆ§ÈÖçÈ¢ùÈÖçÁΩÆÔºö10GB')
    }

    if (userQuotaExists.count === 0) {
      const userQuotaId = `quota_user_${Date.now()}`
      sqlite.exec(`
        INSERT INTO role_quota_config (id, role, default_quota, description, created_at, updated_at)
        VALUES ('${userQuotaId}', 'user', ${1 * 1024 * 1024 * 1024}, 'ÊôÆÈÄöÁî®Êà∑ÈªòËÆ§ÈÖçÈ¢ùÔºö1GB', ${Date.now()}, ${Date.now()})
      `)
      logger.database('INSERT', 'role_quota_config')
      logger.dbInfo('Â∑≤ÂàõÂª∫ÊôÆÈÄöÁî®Êà∑ÈªòËÆ§ÈÖçÈ¢ùÈÖçÁΩÆÔºö1GB')
    }

    // ‰∏∫Áé∞ÊúâÁî®Êà∑ÂàõÂª∫ÈÖçÈ¢ùËÆ∞ÂΩï
    const usersWithoutQuota = sqlite.prepare(`
      SELECT u.id, u.role
      FROM users u
      LEFT JOIN user_quotas uq ON u.id = uq.user_id
      WHERE uq.user_id IS NULL
    `).all()

    for (const user of usersWithoutQuota) {
      const quotaConfig = sqlite.prepare("SELECT default_quota FROM role_quota_config WHERE role = ?").get(user.role)
      const defaultQuota = quotaConfig ? quotaConfig.default_quota : (user.role === 'admin' ? 10 * 1024 * 1024 * 1024 : 1 * 1024 * 1024 * 1024)

      // ËÆ°ÁÆóÁî®Êà∑ÂΩìÂâç‰ΩøÁî®ÈáèÔºàÂåÖÊã¨Êú¨Âú∞Â≠òÂÇ®ÂíåR2Â≠òÂÇ®Ôºâ
      const userFiles = sqlite.prepare("SELECT COALESCE(SUM(size), 0) as total_size FROM files WHERE user_id = ?").get(user.id)
      const totalUsedStorage = userFiles ? userFiles.total_size : 0

      // ÂàÜÂà´ÁªüËÆ°Êú¨Âú∞Â≠òÂÇ®ÂíåR2Â≠òÂÇ®ÔºàÁî®‰∫éÊó•ÂøóÔºâ
      const localFiles = sqlite.prepare("SELECT COALESCE(SUM(size), 0) as local_size FROM files WHERE user_id = ? AND storage_type = 'local'").get(user.id)
      const r2Files = sqlite.prepare("SELECT COALESCE(SUM(size), 0) as r2_size FROM files WHERE user_id = ? AND storage_type = 'r2'").get(user.id)
      const localStorage = localFiles ? localFiles.local_size : 0
      const r2Storage = r2Files ? r2Files.r2_size : 0

      const quotaId = `quota_${user.id}_${Date.now()}`
      sqlite.exec(`
        INSERT INTO user_quotas (id, user_id, max_storage, used_storage, role, created_at, updated_at)
        VALUES ('${quotaId}', '${user.id}', ${defaultQuota}, ${totalUsedStorage}, '${user.role}', ${Date.now()}, ${Date.now()})
      `)
      logger.database('INSERT', 'user_quotas')
      logger.dbInfo(`Â∑≤‰∏∫Áî®Êà∑ ${user.id} (${user.role}) ÂàõÂª∫ÈÖçÈ¢ùËÆ∞ÂΩïÔºö${Math.round(defaultQuota / 1024 / 1024 / 1024)}GBÔºåÂ∑≤‰ΩøÁî®Ôºö${Math.round(totalUsedStorage / 1024 / 1024)}MB (Êú¨Âú∞: ${Math.round(localStorage / 1024 / 1024)}MB, R2: ${Math.round(r2Storage / 1024 / 1024)}MB)`)
    }

    logger.dbInfo('Áî®Êà∑ÈÖçÈ¢ùÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàê')
  } catch (error) {
    logger.error('Áî®Êà∑ÈÖçÈ¢ùÁ≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•:', error)
    throw error
  }
}

// ‰øÆÂ§ç file_direct_links Ë°®ÁªìÊûÑ
async function fixFileDirectLinksTable() {
  try {
    logger.info('üîß Ê£ÄÊü•Âπ∂‰øÆÂ§ç file_direct_links Ë°®ÁªìÊûÑ...')

    // Ê£ÄÊü•Ë°®ÊòØÂê¶Â≠òÂú®
    const tableExists = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name='file_direct_links'
    `).get()

    if (!tableExists) {
      logger.dbInfo('file_direct_links Ë°®‰∏çÂ≠òÂú®ÔºåÈáçÊñ∞ÂàõÂª∫...')
      sqlite.exec(`
        CREATE TABLE file_direct_links (
          id TEXT PRIMARY KEY,
          file_id TEXT UNIQUE NOT NULL,
          user_id TEXT NOT NULL,
          direct_name TEXT UNIQUE NOT NULL,
          token TEXT UNIQUE NOT NULL,
          enabled INTEGER NOT NULL DEFAULT 1,
          access_count INTEGER NOT NULL DEFAULT 0,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE,
          FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        );
      `)
      logger.database('CREATE', 'file_direct_links')
      logger.dbInfo('file_direct_links Ë°®ÂàõÂª∫ÊàêÂäü')
      return
    }

    // Ê£ÄÊü•Ë°®ÁªìÊûÑ
    const columns = sqlite.prepare("PRAGMA table_info(file_direct_links)").all() as Array<{ name: string }>
    const columnNames = columns.map(col => col.name)

    const requiredColumns = [
      'id', 'file_id', 'user_id', 'direct_name', 'token',
      'enabled', 'access_count', 'created_at', 'updated_at'
    ]

    const missingColumns = requiredColumns.filter(col => !columnNames.includes(col))

    if (missingColumns.length > 0) {
      logger.dbInfo(`file_direct_links Ë°®Áº∫Â∞ëÂ≠óÊÆµ: ${missingColumns.join(', ')}`)

      // ÁâπÂà´Â§ÑÁêÜ token Â≠óÊÆµ
      if (missingColumns.includes('token')) {
        logger.dbInfo('Ê∑ªÂä† token Â≠óÊÆµÂà∞ file_direct_links Ë°®...')

        // ‰∏∫Áé∞ÊúâËÆ∞ÂΩïÁîüÊàêtoken
        const { nanoid } = await import('nanoid')
        const existingLinks = sqlite.prepare("SELECT id FROM file_direct_links").all()

        // ÂÖàÊ∑ªÂä†Â≠óÊÆµ
        sqlite.exec('ALTER TABLE file_direct_links ADD COLUMN token TEXT')

        // ‰∏∫Áé∞ÊúâËÆ∞ÂΩïÁîüÊàêÂîØ‰∏Ätoken
        for (const link of existingLinks) {
          const token = nanoid(32)
          sqlite.prepare("UPDATE file_direct_links SET token = ? WHERE id = ?").run(token, link.id)
        }

        logger.database('ALTER', 'file_direct_links')
        logger.dbInfo('token Â≠óÊÆµÊ∑ªÂä†ÊàêÂäüÔºåÂ∑≤‰∏∫Áé∞ÊúâËÆ∞ÂΩïÁîüÊàêtoken')
      }

      // Â§ÑÁêÜÂÖ∂‰ªñÁº∫Â§±Â≠óÊÆµ
      for (const column of missingColumns) {
        if (column === 'token') continue // Â∑≤Â§ÑÁêÜ

        let columnDef = ''
        switch (column) {
          case 'enabled':
            columnDef = 'enabled INTEGER NOT NULL DEFAULT 1'
            break
          case 'access_count':
            columnDef = 'access_count INTEGER NOT NULL DEFAULT 0'
            break
          case 'updated_at':
            columnDef = 'updated_at INTEGER NOT NULL DEFAULT 0'
            break
          default:
            continue
        }

        logger.dbInfo(`Ê∑ªÂä† ${column} Â≠óÊÆµÂà∞ file_direct_links Ë°®...`)
        sqlite.exec(`ALTER TABLE file_direct_links ADD COLUMN ${columnDef}`)
        logger.database('ALTER', 'file_direct_links')
        logger.dbInfo(`${column} Â≠óÊÆµÊ∑ªÂä†ÊàêÂäü`)
      }

      // Êõ¥Êñ∞ updated_at Â≠óÊÆµ‰∏∫ created_at ÁöÑÂÄºÔºàÂ¶ÇÊûú‰∏∫0Ôºâ
      if (missingColumns.includes('updated_at')) {
        sqlite.exec(`UPDATE file_direct_links SET updated_at = created_at WHERE updated_at = 0`)
        logger.dbInfo('Â∑≤Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩïÁöÑ updated_at Â≠óÊÆµ')
      }
    } else {
      logger.dbInfo('file_direct_links Ë°®ÁªìÊûÑÊ≠£Á°Æ')
    }

  } catch (error) {
    logger.error('‰øÆÂ§ç file_direct_links Ë°®Â§±Ë¥•:', error)
    throw error
  }
}

// ‰øÆÂ§ç direct_link_access_logs Ë°®ÁªìÊûÑ
async function fixDirectLinkAccessLogsTable() {
  try {
    logger.info('üîß Ê£ÄÊü•Âπ∂‰øÆÂ§ç direct_link_access_logs Ë°®ÁªìÊûÑ...')

    // Ê£ÄÊü•Ë°®ÊòØÂê¶Â≠òÂú®
    const tableExists = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name='direct_link_access_logs'
    `).get()

    if (!tableExists) {
      logger.dbInfo('direct_link_access_logs Ë°®‰∏çÂ≠òÂú®ÔºåÈáçÊñ∞ÂàõÂª∫...')
      sqlite.exec(`
        CREATE TABLE direct_link_access_logs (
          id TEXT PRIMARY KEY,
          direct_link_id TEXT NOT NULL,
          ip_address TEXT NOT NULL,
          user_agent TEXT,
          country TEXT,
          province TEXT,
          city TEXT,
          isp TEXT,
          accessed_at INTEGER NOT NULL,
          FOREIGN KEY (direct_link_id) REFERENCES file_direct_links (id) ON DELETE CASCADE
        );
      `)
      logger.database('CREATE', 'direct_link_access_logs')
      logger.dbInfo('direct_link_access_logs Ë°®ÂàõÂª∫ÊàêÂäü')
      return
    }

    // Ê£ÄÊü•Ë°®ÁªìÊûÑ
    const columns = sqlite.prepare("PRAGMA table_info(direct_link_access_logs)").all() as Array<{ name: string }>
    const columnNames = columns.map(col => col.name)

    const requiredColumns = [
      'id', 'direct_link_id', 'ip_address', 'user_agent',
      'country', 'province', 'city', 'isp', 'accessed_at'
    ]

    const missingColumns = requiredColumns.filter(col => !columnNames.includes(col))

    if (missingColumns.length > 0) {
      logger.dbInfo(`direct_link_access_logs Ë°®Áº∫Â∞ëÂ≠óÊÆµ: ${missingColumns.join(', ')}ÔºåÈáçÂª∫Ë°®...`)

      // Â§á‰ªΩÁé∞ÊúâÊï∞ÊçÆ
      const existingData = sqlite.prepare("SELECT * FROM direct_link_access_logs").all()

      // Âà†Èô§ÊóßË°®
      sqlite.exec("DROP TABLE direct_link_access_logs")

      // ÈáçÊñ∞ÂàõÂª∫Ë°®
      sqlite.exec(`
        CREATE TABLE direct_link_access_logs (
          id TEXT PRIMARY KEY,
          direct_link_id TEXT NOT NULL,
          ip_address TEXT NOT NULL,
          user_agent TEXT,
          country TEXT,
          province TEXT,
          city TEXT,
          isp TEXT,
          accessed_at INTEGER NOT NULL,
          FOREIGN KEY (direct_link_id) REFERENCES file_direct_links (id) ON DELETE CASCADE
        );
      `)

      // ÊÅ¢Â§çÊï∞ÊçÆÔºàÂè™ÊÅ¢Â§çÂÖºÂÆπÁöÑÂ≠óÊÆµÔºâ
      for (const row of existingData) {
        try {
          sqlite.prepare(`
            INSERT INTO direct_link_access_logs
            (id, direct_link_id, ip_address, user_agent, country, province, city, isp, accessed_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `).run(
            row.id || `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            row.direct_link_id,
            row.ip_address,
            row.user_agent || null,
            row.country || null,
            row.province || null,
            row.city || null,
            row.isp || null,
            row.accessed_at || Date.now()
          )
        } catch (error) {
          logger.warn(`ÊÅ¢Â§çËÆøÈóÆÊó•ÂøóËÆ∞ÂΩïÂ§±Ë¥•: ${error.message}`)
        }
      }

      logger.database('REBUILD', 'direct_link_access_logs')
      logger.dbInfo('direct_link_access_logs Ë°®ÈáçÂª∫ÂÆåÊàê')
    } else {
      logger.dbInfo('direct_link_access_logs Ë°®ÁªìÊûÑÊ≠£Á°Æ')
    }

  } catch (error) {
    logger.error('‰øÆÂ§ç direct_link_access_logs Ë°®Â§±Ë¥•:', error)
    throw error
  }
}

// ‰øÆÂ§ç ip_bans Ë°®ÁªìÊûÑ
async function fixIPBansTable() {
  try {
    logger.info('üîß Ê£ÄÊü•Âπ∂‰øÆÂ§ç ip_bans Ë°®ÁªìÊûÑ...')

    // Ê£ÄÊü•Ë°®ÊòØÂê¶Â≠òÂú®
    const tableExists = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name='ip_bans'
    `).get()

    if (!tableExists) {
      logger.dbInfo('ip_bans Ë°®‰∏çÂ≠òÂú®ÔºåÈáçÊñ∞ÂàõÂª∫...')
      sqlite.exec(`
        CREATE TABLE ip_bans (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          direct_link_id TEXT,
          ip_address TEXT NOT NULL,
          reason TEXT,
          enabled INTEGER NOT NULL DEFAULT 1,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
          FOREIGN KEY (direct_link_id) REFERENCES file_direct_links (id) ON DELETE CASCADE
        );
      `)
      logger.database('CREATE', 'ip_bans')
      logger.dbInfo('ip_bans Ë°®ÂàõÂª∫ÊàêÂäü')
      return
    }

    // Ê£ÄÊü•Ë°®ÁªìÊûÑ
    const columns = sqlite.prepare("PRAGMA table_info(ip_bans)").all() as Array<{ name: string }>
    const columnNames = columns.map(col => col.name)

    const requiredColumns = [
      'id', 'user_id', 'direct_link_id', 'ip_address',
      'reason', 'enabled', 'created_at', 'updated_at'
    ]

    const missingColumns = requiredColumns.filter(col => !columnNames.includes(col))

    if (missingColumns.length > 0) {
      logger.dbInfo(`ip_bans Ë°®Áº∫Â∞ëÂ≠óÊÆµ: ${missingColumns.join(', ')}ÔºåÈáçÂª∫Ë°®...`)

      // Â§á‰ªΩÁé∞ÊúâÊï∞ÊçÆ
      const existingData = sqlite.prepare("SELECT * FROM ip_bans").all()

      // Âà†Èô§ÊóßË°®
      sqlite.exec("DROP TABLE ip_bans")

      // ÈáçÊñ∞ÂàõÂª∫Ë°®
      sqlite.exec(`
        CREATE TABLE ip_bans (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          direct_link_id TEXT,
          ip_address TEXT NOT NULL,
          reason TEXT,
          enabled INTEGER NOT NULL DEFAULT 1,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
          FOREIGN KEY (direct_link_id) REFERENCES file_direct_links (id) ON DELETE CASCADE
        );
      `)

      // ÊÅ¢Â§çÊï∞ÊçÆÔºàÂè™ÊÅ¢Â§çÂÖºÂÆπÁöÑÂ≠óÊÆµÔºâ
      for (const row of existingData) {
        try {
          sqlite.prepare(`
            INSERT INTO ip_bans
            (id, user_id, direct_link_id, ip_address, reason, enabled, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
          `).run(
            row.id || `ban_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            row.user_id,
            row.direct_link_id || null,
            row.ip_address,
            row.reason || null,
            row.enabled !== undefined ? row.enabled : 1,
            row.created_at || Date.now(),
            row.updated_at || Date.now()
          )
        } catch (error) {
          logger.warn(`ÊÅ¢Â§çIPÂ∞ÅÁ¶ÅËÆ∞ÂΩïÂ§±Ë¥•: ${error.message}`)
        }
      }

      logger.database('REBUILD', 'ip_bans')
      logger.dbInfo('ip_bans Ë°®ÈáçÂª∫ÂÆåÊàê')
    } else {
      logger.dbInfo('ip_bans Ë°®ÁªìÊûÑÊ≠£Á°Æ')
    }

  } catch (error) {
    logger.error('‰øÆÂ§ç ip_bans Ë°®Â§±Ë¥•:', error)
    throw error
  }
}

// È™åËØÅÊï∞ÊçÆÂ∫ìË°®ÊòØÂê¶Ê≠£Á°ÆÂàõÂª∫
async function validateDatabaseTables() {
  try {
    logger.dbInfo('üîç È™åËØÅÊï∞ÊçÆÂ∫ìË°®ÁªìÊûÑ...')

    // ÂÆö‰πâÊâÄÊúâÂ∫îËØ•Â≠òÂú®ÁöÑË°®
    const requiredTables = [
      'users',
      'folders',
      'files',
      'storage_config',
      'r2_mount_points',
      'onedrive_auth',
      'onedrive_mount_points',
      'email_verification_codes',
      'smtp_config',
      'download_tokens',
      'file_direct_links',
      'direct_link_access_logs',
      'ip_bans',
      'file_shares',
      'user_quotas',
      'role_quota_config'
    ]

    // Ëé∑ÂèñÊï∞ÊçÆÂ∫ì‰∏≠ÂÆûÈôÖÂ≠òÂú®ÁöÑË°®
    const existingTables = sqlite.prepare(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name NOT LIKE 'sqlite_%'
    `).all().map(row => row.name)

    // Ê£ÄÊü•Áº∫Â§±ÁöÑË°®
    const missingTables = requiredTables.filter(table => !existingTables.includes(table))

    if (missingTables.length > 0) {
      logger.error(`‚ùå Áº∫Â§±ÁöÑÊï∞ÊçÆÂ∫ìË°®: ${missingTables.join(', ')}`)
      throw new Error(`Êï∞ÊçÆÂ∫ìË°®‰∏çÂÆåÊï¥ÔºåÁº∫Â§±: ${missingTables.join(', ')}`)
    }

    // Ê£ÄÊü•È¢ùÂ§ñÁöÑË°®ÔºàÂèØËÉΩÊòØÊóßÁâàÊú¨ÈÅóÁïôÔºâ
    const extraTables = existingTables.filter(table => !requiredTables.includes(table))
    if (extraTables.length > 0) {
      logger.dbInfo(`‚ÑπÔ∏è ÂèëÁé∞È¢ùÂ§ñÁöÑË°®ÔºàÂèØËÉΩÊòØÊóßÁâàÊú¨ÈÅóÁïôÔºâ: ${extraTables.join(', ')}`)
    }

    logger.dbInfo(`‚úÖ Êï∞ÊçÆÂ∫ìË°®È™åËØÅÈÄöËøáÔºåÂÖ± ${requiredTables.length} ‰∏™Ë°®`)

    // ËÆ∞ÂΩïÊØè‰∏™Ë°®ÁöÑËÆ∞ÂΩïÊï∞
    for (const table of requiredTables) {
      try {
        const count = sqlite.prepare(`SELECT COUNT(*) as count FROM ${table}`).get()
        logger.debug(`  ${table}: ${count.count} Êù°ËÆ∞ÂΩï`)
      } catch (error) {
        logger.warn(`  ${table}: Êó†Ê≥ïËé∑ÂèñËÆ∞ÂΩïÊï∞ - ${error.message}`)
      }
    }

  } catch (error) {
    logger.error('Êï∞ÊçÆÂ∫ìË°®È™åËØÅÂ§±Ë¥•:', error)
    throw error
  }
}

// ÂàùÂßãÂåñÁÆ°ÁêÜÂëòË¥¶Êà∑
async function initializeAdminAccount() {
  try {
    logger.info('üîß ÂàùÂßãÂåñÁÆ°ÁêÜÂëòË¥¶Êà∑...')

    // Ê£ÄÊü•ÁÆ°ÁêÜÂëòË¥¶Êà∑ÊòØÂê¶Â∑≤Â≠òÂú®
    const adminExists = sqlite.prepare("SELECT COUNT(*) as count FROM users WHERE id = 'admin'").get()

    if (adminExists.count === 0) {
      // ÁîüÊàêÈöèÊú∫ÂØÜÁ†Å
      const { plainPassword, hashedPassword } = await generateAdminPassword()

      // ÂàõÂª∫ÁÆ°ÁêÜÂëòË¥¶Êà∑
      sqlite.exec(`
        INSERT INTO users (id, email, password, role, email_verified, created_at, updated_at)
        VALUES ('admin', 'admin@cialloo.site', '${hashedPassword}', 'admin', 1, ${Date.now()}, ${Date.now()})
      `)

      logger.database('INSERT', 'users')
      logger.dbInfo('‚úÖ ÁÆ°ÁêÜÂëòË¥¶Êà∑ÂàõÂª∫ÊàêÂäü')

      // Âú®ÊéßÂà∂Âè∞ÊòæÁ§∫ÁôªÂΩï‰ø°ÊÅØ
      console.log('\n' + '='.repeat(80))
      console.log('üîê ÁÆ°ÁêÜÂëòË¥¶Êà∑‰ø°ÊÅØ')
      console.log('='.repeat(80))
      console.log(`üìß ÁôªÂΩïÈÇÆÁÆ±: admin@cialloo.site`)
      console.log(`üîë ÁôªÂΩïÂØÜÁ†Å: ${plainPassword}`)
      console.log('='.repeat(80))
      console.log('‚ö†Ô∏è  ËØ∑Â¶•ÂñÑ‰øùÂ≠ò‰∏äËø∞ÂØÜÁ†ÅÔºåÈ¶ñÊ¨°ÁôªÂΩïÂêéÂª∫ËÆÆÂú®ÁÆ°ÁêÜÈù¢Êùø‰∏≠‰øÆÊîπÂØÜÁ†Å')
      console.log('='.repeat(80) + '\n')

    } else {
      logger.dbInfo('ÁÆ°ÁêÜÂëòË¥¶Êà∑Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫')
    }
  } catch (error) {
    logger.error('ÁÆ°ÁêÜÂëòË¥¶Êà∑ÂàùÂßãÂåñÂ§±Ë¥•:', error)
    throw error
  }
}

// ÊâßË°åÂàùÂßãÂåñ
initializeDatabase().catch(error => {
  logger.error('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•:', error)
  process.exit(1)
})

export { sqlite }
